# 아키텍처 문서 - Container System

> **버전:** 0.1.0.0
> **최종 업데이트:** 2025-10-22
> **언어:** [English](ARCHITECTURE.md) | **한국어**

---

## 목차

- [설계 철학](#설계-철학)
- [최소 의존성 아키텍처](#최소-의존성-아키텍처)
- [핵심 원칙](#핵심-원칙)
- [시스템 아키텍처](#시스템-아키텍처)
- [컴포넌트 아키텍처](#컴포넌트-아키텍처)
- [통합 아키텍처](#통합-아키텍처)
- [메모리 관리](#메모리-관리)
- [성능 최적화](#성능-최적화)
- [직렬화 아키텍처](#직렬화-아키텍처)
- [디자인 패턴](#디자인-패턴)
- [스레드 안전성 아키텍처](#스레드-안전성-아키텍처)
- [오류 처리 전략](#오류-처리-전략)

---

## 설계 철학

Container System은 세 가지 기본 원칙을 중심으로 설계되었습니다:

### 1. 성능 저하 없는 타입 안전성

시스템은 C++20 concepts와 `std::variant`를 통해 컴파일 타임 타입 안전성을 제공하며, 타입 검사에 대한 런타임 오버헤드가 전혀 없으면서 일반적인 프로그래밍 오류를 방지합니다.

**주요 설계 결정:**
- 다형성 값 저장을 위한 `std::variant` 사용 (컴파일 타임 타입 안전성)
- 타입 안전한 값 팩토리를 위한 템플릿 메타프로그래밍
- 컴파일 타임 타입 매핑을 위한 Constexpr 함수
- 인라인 함수와 이동 의미론을 통한 제로 비용 추상화

### 2. 기본적으로 성능 중심

모든 컴포넌트는 사용자의 수동 최적화 없이 고처리량 시나리오에 최적화되어 있습니다.

**성능 특성:**
- 컨테이너 생성: 5M 컨테이너/초 (빈 컨테이너)
- 바이너리 직렬화: 2M 컨테이너/초 (평균 1KB 크기)
- SIMD 가속 연산: 25M 숫자 연산/초
- 메모리 효율성: ~128 바이트 기본 크기 + variant 저장소

### 3. 통합 우선 설계

아키텍처는 독립적인 사용성을 유지하면서 다른 생태계 컴포넌트와의 원활한 통합을 우선시합니다.

**통합 이점:**
- 메시징, 네트워크, 데이터베이스 시스템 전반에 걸친 통합 데이터 모델
- 각 전송 계층에 최적화된 네이티브 직렬화 형식
- 레거시 messaging_system 컨테이너와의 하위 호환성
- 사용자 정의 통합을 위한 확장 가능한 값 타입 시스템

---

## 최소 의존성 아키텍처

container_system은 생태계에서 **이상적인 의존성 패턴**을 대표하며, 모듈이 최대한의 격리와 유지보수성을 위해 어떻게 설계되어야 하는지를 보여줍니다.

### 의존성 철학

#### 최소 의존성이 중요한 이유

1. **빌드 격리**: 의존성이 적은 모듈은 독립적으로 빌드하고 테스트하기 쉽습니다
2. **복잡성 감소**: 의존성이 적으면 잠재적 충돌이 줄고 디버깅이 쉬워집니다
3. **빠른 컴파일**: 최소 의존성은 컴파일 시간을 크게 줄입니다
4. **쉬운 유지보수**: 결합도가 낮으면 한 모듈의 변경이 다른 모듈에 영향을 주지 않습니다
5. **명확한 아키텍처**: 단순한 의존성 그래프는 이해하고 유지하기 쉽습니다

#### container_system이 격리를 달성하는 방법

container_system은 생태계에서 가장 깔끔한 의존성 구조를 가지고 있습니다:

```
container_system
       │
       ▼
common_system (유일한 필수 의존성)
```

| 측면 | 상태 | 비고 |
|--------|--------|-------|
| 필수 의존성 | 1 (common_system) | 최소 |
| 선택적 의존성 | 0 | 조건부 컴파일 불필요 |
| 순환 의존성 위험 | 없음 | 아래 방향으로만 의존 |
| 격리 빌드 | ✅ | common_system만으로 빌드 가능 |

### 핵심 설계 결정

1. **common_system의 인터페이스 사용**: 다른 모듈의 구체적인 구현에 의존하는 대신, common_system에 정의된 추상 인터페이스 사용
2. **외부 vs 생태계 의존성**: 외부 라이브러리(gRPC, Protobuf)는 생태계 의존성이 아님 - 선택적 외부 도구
3. **하향 전용 의존성**: container_system은 하위 계층 모듈(common_system은 Tier 0)에만 의존

### 통합 패턴

#### 다른 모듈이 container_system과 통합하는 방법

생태계의 다른 모듈은 container_system**에** 통합되며, 그 반대는 아닙니다:

```
┌────────────────────┐
│  messaging_system  │ ──의존──▶ container_system
└────────────────────┘
┌────────────────────┐
│  network_system    │ ──의존──▶ container_system
└────────────────────┘
┌────────────────────┐
│  database_system   │ ──의존──▶ container_system
└────────────────────┘
```

이 패턴은 다음을 보장합니다:
- container_system은 가볍고 집중된 상태 유지
- 상위 레벨 모듈이 container_system에 의존성을 추가하지 않고 컨테이너 직렬화 사용 가능
- 단방향 의존성을 가진 명확한 계층화 아키텍처

### 외부 의존성

container_system은 선택적 외부(비생태계) 의존성을 가지고 있습니다:

| 의존성 | 유형 | 필수 | 목적 |
|------------|------|----------|---------|
| gRPC | 외부 | 선택적 | RPC 통신 |
| Protobuf | 외부 | 선택적 | 프로토콜 버퍼 직렬화 |
| Google Test | 외부 | 선택적 | 단위 테스트 |
| Google Benchmark | 외부 | 선택적 | 성능 벤치마킹 |

이들은 생태계 의존성이 아닌 **외부** 의존성입니다:
- 조건부 컴파일 (비활성화 가능)
- 핵심 기능에 영향 없음
- 특정 기능에만 필요

### 빌드 구성

#### 최소 빌드 (코어만)

```bash
# common_system만 필요
cmake -S . -B build \
    -DENABLE_GRPC=OFF \
    -DBUILD_TESTING=OFF \
    -DBUILD_BENCHMARKS=OFF

cmake --build build
```

#### gRPC 지원 포함

```bash
cmake -S . -B build \
    -DENABLE_GRPC=ON

cmake --build build
```

### 최소 의존성 체크리스트

새 모듈을 설계하거나 기존 모듈을 검토할 때 최소 의존성 아키텍처를 달성하기 위해 이 체크리스트를 사용하세요:

```markdown
## 최소 의존성 체크리스트

- [ ] 하위 계층 모듈에만 의존 (Tier 1의 경우 common_system)
- [ ] 직접 모듈 의존성 대신 common_system의 인터페이스 사용
- [ ] 외부 의존성(gRPC, OpenSSL)은 생태계 의존성이 아님
- [ ] 모든 선택적 생태계 통합은 조건부 컴파일 사용
- [ ] 필수 의존성만으로 모듈 빌드 및 테스트 가능
- [ ] 순환 의존성 위험 없음 (아래 방향으로만 의존)
- [ ] 핵심 기능과 선택적 기능의 명확한 분리
- [ ] CMakeLists.txt와 README에 의존성 문서화
```

### 의존성 계층 시스템

생태계는 의존성에 대해 계층 시스템을 따릅니다:

```
Tier 0: common_system (기반)
    ↓
Tier 1: container_system (데이터 레이어)
    ↓
Tier 2: messaging_system, network_system (통신 레이어)
    ↓
Tier 3: database_system (저장 레이어)
    ↓
Tier 4: 애플리케이션 모듈
```

**규칙:**
- 모듈은 하위 계층의 모듈에만 의존할 수 있음
- 순환 의존성 금지
- 외부 의존성은 계층 배치에 영향 없음

---

## 핵심 원칙

### 모듈성

시스템은 명확한 책임을 가진 느슨하게 결합된 모듈로 구성되어 있습니다:

```
Core Layer (container, value, value_types)
    ↓
Value Layer (primitive, numeric, container, bytes)
    ↓
Advanced Layer (variant, thread_safe, SIMD)
    ↓
Serialization Layer (binary, JSON, XML)
    ↓
Integration Layer (messaging, network, database)
```

### 확장성

새로운 값 타입과 직렬화 형식을 기존 코드 수정 없이 추가할 수 있습니다:

- enum과 constexpr 매핑을 통해 정의된 값 타입
- 공통 인터페이스를 구현하는 직렬화 형식
- 타입 안전한 값 생성을 위한 팩토리 패턴
- 타입 안전한 값 처리를 위한 방문자 패턴

### 성능

최적화는 여러 수준에서 적용됩니다:

1. **컴파일 타임**: 템플릿 메타프로그래밍, constexpr 함수
2. **메모리**: Variant 저장소, 작은 버퍼 최적화, 메모리 풀링
3. **CPU**: SIMD 명령어 (NEON, AVX2), 캐시 친화적 레이아웃
4. **I/O**: 제로 카피 직렬화, 효율적인 바이너리 형식

### 안전성

메모리 안전성과 스레드 안전성은 현대적인 C++ 관용구를 통해 강제됩니다:

- 자동 리소스 관리를 위한 RAII (20/20 완벽한 점수)
- 전체적으로 스마트 포인터 (`std::shared_ptr`, `std::unique_ptr`) 사용
- `std::shared_mutex`를 통한 스레드 안전 연산
- 강력한 보장을 가진 예외 안전성

---

## 시스템 아키텍처

### 계층화된 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                        │
│  (Messaging Systems, Network Applications, Database Stores) │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                  Integration Layer                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Messaging   │  │   Network    │  │  Database    │      │
│  │ Integration  │  │ Integration  │  │ Integration  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│               Serialization Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │    Binary    │  │     JSON     │  │     XML      │      │
│  │  Serializer  │  │  Serializer  │  │  Serializer  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                  Advanced Layer                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Variant    │  │ Thread-Safe  │  │     SIMD     │      │
│  │    Value     │  │  Container   │  │  Processor   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                    Value Layer                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Numeric    │  │    String    │  │  Container   │      │
│  │    Values    │  │    Values    │  │    Values    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐                        │
│  │     Bool     │  │    Bytes     │                        │
│  │    Values    │  │    Values    │                        │
│  └──────────────┘  └──────────────┘                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                     Core Layer                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Container   │  │     Value    │  │ Value Types  │      │
│  │    Class     │  │   Interface  │  │   (Enum)     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

---

## 통합 아키텍처

### 생태계 통합 다이어그램

```
┌───────────────────────────────────────────────────────────┐
│                    utilities_module                       │
│  (문자열 변환, 시스템 유틸리티, 플랫폼 지원)                  │
└─────────────────────────┬─────────────────────────────────┘
                          │ Foundation dependency
                          ▼
┌───────────────────────────────────────────────────────────┐
│                  container_system (Core)                  │
│  • 타입 안전 컨테이너                                       │
│  • 15가지 값 타입                                          │
│  • SIMD 최적화                                            │
│  • Binary/JSON/XML 직렬화                                 │
└────┬──────────────┬──────────────┬────────────────┬───────┘
     │              │              │                │
     ▼              ▼              ▼                ▼
┌─────────┐  ┌──────────┐  ┌──────────┐  ┌──────────────┐
│messaging│  │ network  │  │ database │  │common_system │
│ _system │  │ _system  │  │ _system  │  │ (Result<T>)  │
└─────────┘  └──────────┘  └──────────┘  └──────────────┘
     │              │              │                │
     └──────────────┴──────────────┴────────────────┘
                          │
                          ▼
                 ┌────────────────┐
                 │  Application   │
                 │     Layer      │
                 └────────────────┘
```

---

## 메모리 관리

### RAII 우수성 (20/20 완벽한 점수)

Container System은 전체 생태계에서 가장 높은 RAII 점수를 달성했으며 참조 구현으로 사용됩니다.

**RAII 구현:**

1. **스마트 포인터 사용 (5/5):**
   - 값 저장을 위한 100% `std::shared_ptr`
   - 내부 버퍼를 위한 `std::unique_ptr`
   - 원시 포인터 소유권 없음

2. **RAII 래퍼 클래스 (5/5):**
   - 직렬화 버퍼 래퍼
   - 스레드 안전 컨테이너 래퍼
   - 자동 리소스 정리

3. **예외 안전성 (4/4):**
   - 강력한 예외 안전성 보장
   - 예외 발생 시 리소스 누수 없음
   - 트랜잭션 방식의 값 업데이트

4. **이동 의미론 (3/3):**
   - 제로 카피 값 전송
   - 4.2M 이동/초 성능
   - 전체적으로 완벽한 전달

5. **리소스 누수 방지 (3/3):**
   - AddressSanitizer 검증 (누수 0건)
   - 자동 정리 검증 완료
   - 수동 메모리 관리 없음

---

## 성능 최적화

### 다층 최적화 전략

**1. 컴파일 타임 최적화:**
- Constexpr 타입 매핑 (런타임 오버헤드 제로)
- 타입 안전성을 위한 템플릿 메타프로그래밍
- 핫 패스를 위한 인라인 함수
- 링크 타임 최적화 (LTO)

**2. 메모리 최적화:**
- Variant 저장소 (최소 다형성 오버헤드)
- 문자열을 위한 작은 문자열 최적화 (SSO)
- 빈번한 할당을 위한 메모리 풀링
- 캐시 친화적 데이터 레이아웃

**3. CPU 최적화:**
- SIMD 명령어 (NEON, AVX2, SSE4.2)
- 분기 예측 힌트
- 직렬화를 위한 루프 언롤링
- 대량 연산을 위한 프리페칭

**4. I/O 최적화:**
- 제로 카피 직렬화 경로
- 대용량 데이터를 위한 버퍼링 I/O
- 네트워크 I/O를 위한 scatter-gather
- 영속성을 위한 메모리 매핑 파일

---

## 직렬화 아키텍처

### 형식 비교

| 형식 | 처리량 | 크기 오버헤드 | 사용 사례 | 검증 |
|--------|------------|---------------|----------|------------|
| **Binary** | 2M/s | ~10% | 네트워크, IPC, 저장소 | CRC 선택적 |
| **JSON** | 800K/s | ~40% | REST API, 디버그 | 스키마 선택적 |
| **XML** | 600K/s | ~60% | 레거시, SOAP | XSD 필수 |

---

## 디자인 패턴

### 1. 팩토리 패턴

**이점:**
- 타입 안전한 값 생성
- 중앙 집중식 구성 로직
- 새로운 타입을 위한 확장성

### 2. 빌더 패턴

**이점:**
- 구성을 위한 유창한 API
- 빌드 시점 검증
- 최적화를 위한 성능 힌트

### 3. 방문자 패턴

**이점:**
- 타입 안전한 디스패치
- 확장 가능한 연산
- 컴파일 타임 검사

### 4. 전략 패턴

**이점:**
- 런타임 형식 선택
- 플러그 가능한 직렬화기
- 형식별 최적화

### 5. 어댑터 패턴

**이점:**
- 경계에서 타입 안전한 오류 처리
- 성능을 위한 내부 예외
- 원활한 생태계 통합

---

## 스레드 안전성 아키텍처

### 동시성 모델

**읽기-쓰기 잠금 전략:**
- 읽기 연산: 항상 스레드 안전 (동시 읽기 허용)
- 쓰기 연산: `thread_safe_container` 래퍼로 스레드 안전
- 직렬화: 읽기 전용 컨테이너에 대해 스레드 안전
- 값 접근: 동시 읽기 안전, 쓰기는 동기화 필요

**ThreadSanitizer 준수:**
- 모든 테스트 시나리오에서 데이터 경합 제로 감지
- 불변 컨테이너를 위한 잠금 없는 읽기 연산
- 원자적 연산을 위한 적절한 메모리 순서

---

## 오류 처리 전략

### 하이브리드 접근법: 예외 + Result<T>

**내부 연산 (예외):**
- 고성능 (표준 컨테이너 관행)
- 강력한 예외 안전성 보장
- RAII가 정리를 보장

**외부 API (Result<T>):**
- 경계에서 타입 안전한 오류 처리
- 명시적 오류 전파
- 모나딕 합성 지원

---

## 결론

Container System 아키텍처는 다음을 위해 설계되었습니다:
- **고성능**: SIMD, 제로 카피, 효율적인 메모리 관리
- **타입 안전성**: 컴파일 타임 검사, `std::variant`, 강력한 타이핑
- **확장성**: 팩토리, 방문자, 전략 패턴
- **통합**: 원활한 생태계 상호 운용성
- **신뢰성**: RAII, 스레드 안전성, 예외 안전성

이 아키텍처는 독립적인 사용성과 최적의 성능을 유지하면서 전체 생태계에 걸친 모든 데이터 직렬화 요구사항의 기반으로 사용됩니다.

---

**유지 관리자:** kcenon@naver.com
**라이선스:** BSD 3-Clause
**버전:** 1.0.0
**최종 업데이트:** 2025-10-22
